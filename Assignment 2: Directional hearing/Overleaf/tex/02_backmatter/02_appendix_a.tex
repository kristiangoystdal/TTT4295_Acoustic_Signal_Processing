\chapter{Python Source Code}

\begin{lstlisting}[language=Python, caption={hrir.py}, label={lst:hrir}]

def hrir1(angle, head_radius=0.09, f_s=44100, c=343):
    if angle < -90 or angle > 90:
        print("Angle must be between -90 and 90 degrees.")
        return None, None

    theta = math.radians(angle)
    delta_t = (head_radius / c) * (theta + math.sin(theta))
    n_delay = int(round(abs(delta_t) * f_s))

    # Max possible delay at 90 deg (~30 samples for default params)
    n_max = int(round((head_radius / c) * ((math.pi / 2) + 1) * f_s))

    hrir_left = np.zeros(n_max + 1)
    hrir_right = np.zeros(n_max + 1)

    if angle > 0:  # sound on right
        hrir_right[0] = 1.0
        hrir_left[n_delay] = 1.0
    elif angle < 0:  # sound on left
        hrir_left[0] = 1.0
        hrir_right[n_delay] = 1.0
    else:  # straight ahead
        hrir_left[0] = 1.0
        hrir_right[0] = 1.0

    return hrir_left, hrir_right


\end{lstlisting}

\begin{lstlisting}[language=Python, caption={hrtf.py}, label={lst:hrtf}]
def hrtf1(angle, head_radius=0.09, f_s=44100, c=343, n_fft=512):
    theta = math.radians(angle)
    alpha_L = 1 - math.sin(theta)
    alpha_R = 1 + math.sin(theta)
    beta = 2 * c / head_radius

    f_vec = np.linspace(0, f_s / 2, n_fft // 2 + 1)
    omega = 2 * np.pi * f_vec

    num_L = np.sqrt((alpha_L * omega) ** 2 + beta**2)
    num_R = np.sqrt((alpha_R * omega) ** 2 + beta**2)
    denum = np.sqrt((omega)**2 + beta**2)

    H_L = num_L / denum
    H_R = num_R / denum

    return f_vec, H_L, H_R
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={hrtfiir.py}, label={lst:hrtfirr}]
def hrtfiir(angle, head_radius=0.09, f_s=44100, c=343):
    T = 1 / f_s
    theta = math.radians(angle)
    alpha_L = 1 - math.sin(theta)
    alpha_R = 1 + math.sin(theta)
    beta = 2 * c / head_radius

    # Common
    a_0 = 2 + beta * T
    a_1 = beta * T - 2
    A_1 = a_1 / a_0

    # Left ear
    b_0_L = 2 + alpha_L + beta * T
    b_1_L = beta * T - 2 * alpha_L
    B_0_L = b_0_L / a_0
    B_1_L = b_1_L / a_0

    # Right ear
    b_0_R = 2 + alpha_R + beta * T
    b_1_R = beta * T - 2 * alpha_R
    B_0_R = b_0_R / a_0
    B_1_R = b_1_R / a_0

    return A_1, B_0_L, B_1_L, B_0_R, B_1_R

\end{lstlisting}

\begin{lstlisting}[language=Python, caption={main.py}, label={lst:combined}]
# Task 4: Combined HRIR and HRTF IIR
combined_left = np.convolve(hrir_left, [hrtfiir_left_0, hrtfiir_left_1], "full")
combined_right = np.convolve(hrir_right, [hrtfiir_right_0, hrtfiir_right_1], "full")
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={main.py}, label={lst:sound_demo}]

# Generate pink noise
def pink_noise(N):
    n_rows = 16
    n_cols = N
    array = np.random.randn(n_rows, n_cols)
    array = np.cumsum(array, axis=1)
    pink = np.sum(array, axis=0)
    pink /= np.max(np.abs(pink))
    return pink


# Task 5: Sound playback
step = 30
full_stereo_signal = None
for angle in range(-90, 91, step):
    print(f"Playing sound at {angle} degrees")
    hrir_left, hrir_right = hrir1(angle, head_radius, f_s, c)

    hrtfiir_a, hrtfiir_left_0, hrtfiir_left_1, hrtfiir_right_0, hrtfiir_right_1 = (
        hrtfiir(angle, head_radius, f_s, c)
    )

    combined_left = np.convolve(hrir_left, [hrtfiir_left_0, hrtfiir_left_1], "full")
    combined_right = np.convolve(hrir_right, [hrtfiir_right_0, hrtfiir_right_1], "full")

    # Combine all the segments and play sound
    duration = 1  # seconds
    t = np.linspace(0, duration, int(f_s * duration), endpoint=False)

    mono_signal = 0.5 * pink_noise(len(t))
    stereo_signal = np.zeros((len(mono_signal), 2))
    stereo_signal[:, 0] = np.convolve(mono_signal, combined_left, "same")
    stereo_signal[:, 1] = np.convolve(mono_signal, combined_right, "same")
    if full_stereo_signal is None:
        full_stereo_signal = stereo_signal
    else:
        full_stereo_signal = np.vstack((full_stereo_signal, stereo_signal))

sd.play(full_stereo_signal, f_s)
sd.wait()

\end{lstlisting}